package bakery

import (
	"crypto/rand"
	"fmt"
	"strconv"
	"strings"

	"github.com/juju/loggo"
	"golang.org/x/net/context"
	"gopkg.in/errgo.v1"
	"gopkg.in/macaroon.v2-unstable"

	"gopkg.in/macaroon-bakery.v2-unstable/bakery/checkers"
)

var logger = loggo.GetLogger("bakery")

// LocalThirdPartyCaveat returns a third-party caveat that, when added
// to a macaroon with AddCaveat, results in a caveat
// with the location "local", encrypted with the given public key.
// This can be automatically discharged by DischargeAllWithKey.
func LocalThirdPartyCaveat(key *PublicKey, version Version) checkers.Caveat {
	var loc string
	if version < Version2 {
		loc = "local " + key.String()
	} else {
		loc = fmt.Sprintf("local %d %s", version, key)
	}
	return checkers.Caveat{
		Location: loc,
	}
}

// AddCaveat adds a caveat to the given macaroon.
//
// If it's a third-party caveat, it encrypts it using
// the given key pair and by looking
// up the location using the given locator.
//
// As a special case, if the caveat's Location field has the prefix
// "local " the caveat is added as a client self-discharge caveat
// using the public key base64-encoded in the rest of the location.
// In this case, the Condition field must be empty. The
// resulting third-party caveat will encode the condition "true"
// encrypted with that public key. See LocalThirdPartyCaveat
// for a way of creating such caveats.
func AddCaveat(ctxt context.Context, key *KeyPair, loc ThirdPartyLocator, m *macaroon.Macaroon, cav checkers.Caveat, ns *checkers.Namespace) error {
	if cav.Location == "" {
		if err := m.AddFirstPartyCaveat(ns.ResolveCaveat(cav).Condition); err != nil {
			return errgo.Mask(err)
		}
		return nil
	}
	if key == nil {
		return errgo.Newf("no private key to encrypt third party caveat")
	}
	var info ThirdPartyInfo
	if localInfo, ok := parseLocalLocation(cav.Location); ok {
		info = localInfo
		cav.Location = "local"
		if cav.Condition != "" {
			return errgo.New("cannot specify caveat condition in local third-party caveat")
		}
		cav.Condition = "true"
	} else {
		var err error
		info, err = loc.ThirdPartyInfo(ctxt, cav.Location)
		if err != nil {
			return errgo.Notef(err, "cannot find public key for location %q", cav.Location)
		}
	}
	rootKey, err := randomBytes(24)
	if err != nil {
		return errgo.Notef(err, "cannot generate third party secret")
	}
	if m.Version() < macaroon.V2 && info.Version >= Version2 {
		// We can't use later version of caveat ids in earlier macaroons.
		info.Version = Version1
	}
	id, err := encodeCaveatId(cav.Condition, rootKey, info, key)
	if err != nil {
		return errgo.Notef(err, "cannot create third party caveat id at %q", cav.Location)
	}
	if err := m.AddThirdPartyCaveat(rootKey, id, cav.Location); err != nil {
		return errgo.Notef(err, "cannot add third party caveat")
	}
	return nil
}

// parseLocalLocation parses a local caveat location as generated by
// LocalThirdPartyCaveat. This is of the form:
//
//	local <version> <pubkey>
//
// where <version> is the bakery version of the client that we're
// adding the local caveat for.
//
// It returns false if the location does not represent a local
// caveat location.
func parseLocalLocation(loc string) (ThirdPartyInfo, bool) {
	if !strings.HasPrefix(loc, "local ") {
		return ThirdPartyInfo{}, false
	}
	version := Version1
	fields := strings.Fields(loc)
	fields = fields[1:] // Skip "local"
	switch len(fields) {
	case 2:
		v, err := strconv.Atoi(fields[0])
		if err != nil {
			return ThirdPartyInfo{}, false
		}
		version = Version(v)
		fields = fields[1:]
		fallthrough
	case 1:
		var key PublicKey
		if err := key.UnmarshalText([]byte(fields[0])); err != nil {
			return ThirdPartyInfo{}, false
		}
		return ThirdPartyInfo{
			PublicKey: key,
			Version:   version,
		}, true
	default:
		return ThirdPartyInfo{}, false
	}
}

// Discharge creates a macaroon that discharges the third party caveat with the
// given id that should have been created earlier using key.Public. The
// condition implicit in the id is checked for validity using checker. If
// it is valid, a new macaroon is returned which discharges the caveat
// along with any caveats returned from the checker.
//
// The macaroon is created with a version derived from the version
// that was used to encode the id.
func Discharge(ctxt context.Context, key *KeyPair, checker ThirdPartyCaveatChecker, id []byte) (*macaroon.Macaroon, []checkers.Caveat, error) {
	cavInfo, err := decodeCaveatId(key, []byte(id))
	if err != nil {
		return nil, nil, errgo.Notef(err, "discharger cannot decode caveat id")
	}
	// Note that we don't check the error - we allow the
	// third party checker to see even caveats that we can't
	// understand.
	cond, arg, _ := checkers.ParseCaveat(cavInfo.Condition)

	var caveats []checkers.Caveat
	if cond == checkers.CondNeedDeclared {
		cavInfo.Condition = arg
		caveats, err = checkNeedDeclared(ctxt, cavInfo, checker)
	} else {
		caveats, err = checker.CheckThirdPartyCaveat(ctxt, cavInfo)
	}
	if err != nil {
		return nil, nil, errgo.Mask(err, errgo.Any)
	}
	// Note that the discharge macaroon does not need to
	// be stored persistently. Indeed, it would be a problem if
	// we did, because then the macaroon could potentially be used
	// for normal authorization with the third party.
	m, err := macaroon.New(cavInfo.RootKey, id, "", MacaroonVersion(cavInfo.Version))
	if err != nil {
		return nil, nil, errgo.Mask(err)
	}
	return m, caveats, nil
}

func checkNeedDeclared(ctxt context.Context, cavInfo *ThirdPartyCaveatInfo, checker ThirdPartyCaveatChecker) ([]checkers.Caveat, error) {
	arg := cavInfo.Condition
	i := strings.Index(arg, " ")
	if i <= 0 {
		return nil, errgo.Newf("need-declared caveat requires an argument, got %q", arg)
	}
	needDeclared := strings.Split(arg[0:i], ",")
	for _, d := range needDeclared {
		if d == "" {
			return nil, errgo.New("need-declared caveat with empty required attribute")
		}
	}
	if len(needDeclared) == 0 {
		return nil, fmt.Errorf("need-declared caveat with no required attributes")
	}
	cavInfo.Condition = arg[i+1:]
	caveats, err := checker.CheckThirdPartyCaveat(ctxt, cavInfo)
	if err != nil {
		return nil, errgo.Mask(err, errgo.Any)
	}
	declared := make(map[string]bool)
	for _, cav := range caveats {
		if cav.Location != "" {
			continue
		}
		// Note that we ignore the error. We allow the service to
		// generate caveats that we don't understand here.
		cond, arg, _ := checkers.ParseCaveat(cav.Condition)
		if cond != checkers.CondDeclared {
			continue
		}
		parts := strings.SplitN(arg, " ", 2)
		if len(parts) != 2 {
			return nil, errgo.Newf("declared caveat has no value")
		}
		declared[parts[0]] = true
	}
	// Add empty declarations for everything mentioned in need-declared
	// that was not actually declared.
	for _, d := range needDeclared {
		if !declared[d] {
			caveats = append(caveats, checkers.DeclaredCaveat(d, ""))
		}
	}
	return caveats, nil
}

func randomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return nil, fmt.Errorf("cannot generate %d random bytes: %v", n, err)
	}
	return b, nil
}

// ThirdPartyCaveatInfo holds the information decoded from
// a third party caveat id.
type ThirdPartyCaveatInfo struct {
	// Condition holds the third party condition to be discharged.
	// This is the only field that most third party dischargers will
	// need to consider.
	Condition string

	// FirstPartyPublicKey holds the public key of the party
	// that created the third party caveat.
	FirstPartyPublicKey PublicKey

	// ThirdPartyKeyPair holds the key pair used to decrypt
	// the caveat - the key pair of the discharging service.
	ThirdPartyKeyPair KeyPair

	// RootKey holds the secret root key encoded by the caveat.
	RootKey []byte

	// CaveatId holds the full encoded caveat id from which all
	// the other fields are derived.
	CaveatId []byte

	// MacaroonId holds the id that the discharge macaroon
	// should be given. This is often the same as the
	// CaveatId field.
	MacaroonId []byte

	// Version holds the version that was used to encode
	// the caveat id.
	Version Version
}

// ThirdPartyCaveatChecker holds a function that checks third party caveats
// for validity. If the caveat is valid, it returns a nil error and
// optionally a slice of extra caveats that will be added to the
// discharge macaroon. The caveatId parameter holds the still-encoded id
// of the caveat.
//
// If the caveat kind was not recognised, the checker should return an
// error with a ErrCaveatNotRecognized cause.
type ThirdPartyCaveatChecker interface {
	CheckThirdPartyCaveat(ctxt context.Context, info *ThirdPartyCaveatInfo) ([]checkers.Caveat, error)
}

// ThirdPartyCaveatCheckerFunc implements ThirdPartyCaveatChecker by calling a function.
type ThirdPartyCaveatCheckerFunc func(context.Context, *ThirdPartyCaveatInfo) ([]checkers.Caveat, error)

// CheckThirdPartyCaveat implements ThirdPartyCaveatChecker.CheckThirdPartyCaveat by calling
// the receiver with the given arguments
func (c ThirdPartyCaveatCheckerFunc) CheckThirdPartyCaveat(ctxt context.Context, info *ThirdPartyCaveatInfo) ([]checkers.Caveat, error) {
	return c(ctxt, info)
}

// FirstPartyCaveatChecker is used to check first party caveats
// for validity with respect to information in the provided context.
//
// If the caveat kind was not recognised, the checker should return
// ErrCaveatNotRecognized.
type FirstPartyCaveatChecker interface {
	// CheckFirstPartyCaveat checks that the given caveat condition
	// is valid with respect to the given context information.
	CheckFirstPartyCaveat(ctxt context.Context, caveat string) error

	// Namespace returns the namespace associated with the
	// caveat checker.
	Namespace() *checkers.Namespace
}
